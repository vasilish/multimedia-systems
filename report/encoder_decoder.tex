\chapter{Ολοκληρωμένο σύστημα Κωδικοποιητή \& Αποκωδικοποιητή}

\par Έχοντας ολοκληρώσει όλα τα επιμέρους συστήματα που αποτελούν ένα κωδικοποιητή
αποκωδικοποιητη, τώρα πρέπει να τα συνδέσουμε όλα μεταξύ τους.
Αρχικά παρουσιάζουμε τη διαδικασία που ακολουθήθηκε για την δημιουργία
του κωδικοποιητή.

\section{Ολοκληρωμένος Κωδικοποιητής}
\par Παρακάτω παρουσιάζονται όλα τα βήματα που χρησιμοποιήσαμε για την σύνθεση ενός
κωδικοποιητή και στη συνέχεια τα θα αναλύσουμε το κάθε ένα από αυτά.
\begin{enumerate}
\item Υποδειγματοληψία του αρχικού σήματος.
\item Χωρισμός του σήματος σε παράθυρα καθορισμένου μήκους.
\item Υπολογισμός των παραμέτρων του γραμμικού προβλέπτη.
\item Χρήση του συστήματος A-DPCM.
\item Υπολογισμός μετασχηματισμού Huffman.
\item Εγγραφή των παραμέτρων σε δυαδική μορφή σε αρχείο
\end{enumerate}

\subsection{Υποδειγματοληψία}
\par Το πρώτο πράγμα που θα κάνουμε είναι να μετατρέψουμε το σήμα που έχουμε
σε δειγματοληψία χαμηλότερης συχνότητας. Αυτό θα έχει σαν αποτέλεσμα να χρησιμοποιήσουμε
λιγότερα δείγματα για την κωδικοποίηση, καθώς η υποδειγματοληψία μειώνει το μήκος
του αρχικού σήματος, όπως αναφέραμε και στην αρχή. Για την υποδειγματοληψία θα χρησιμοποιηθεί
η συνάρτηση resample.

\subsection{Δημιουργία παραθύρων}

\par Επειδή το δείγμα μας είναι πολύ μεγάλο είναι αναγκαίο να το χωρίσουμε
σε μικρότερα ανεξάρτητα παράθυρα και να τα κωδικοποιήσουμε ανεξάρτητα το ένα από
το άλλο. Στη συνέχεια για κάθε δείγμα καλούμε τη συνάρτηση
\begin{lstlisting}[style=MyMatlab]
 function [b, newstate] = encoder(x, state)
\end{lstlisting}
όπου x είναι το εκάστοτε παράθυρο και b η κωδικοποίηση του.

\subsection{Υπολογισμός παραμέτρων γραμμικού προβλέπτη}
\par Μέσα στη συνάρτηση encoder θέλουμε να δημιουργήσουμε ένα γραμμικό προβλέπτη για
κάθε παράθυρο. Αυτό το κάνουμε με τη χρήση της συνάρτησης lpcoeffs όπως αναφέραμε και
παραπάνω.

\subsection{Χρήση A-DPCM}
\par Στο σημείο αυτό θέλουμε να χρησιμοποιήσουμε την μέθοδο A-DPCM ώστε να μπορέσουμε
να έχουμε τη δυνατότερη μικρή κωδικοποίηση αποσυσχετίζοντας τα διαδοχικά δείγματα του αρχικού
σήματος μέσω κατάλληλων διαφορών. Για την χρήση όμως του A-DPCM είναι
απαραίτητη η ύπαρξη ενός κβαντιστή. Άρα σε πρώτη φάση δημιουργούμε έναν ομοιόμορφο
κβαντιστή γιατί χρειαζόμαστε τις στάθμες απόφασης και κβαντισμού. Στη συνέχεια
χρησιμοποιούμε την συνάρτηση A-DPCM και υπολογίζουμε τα σύμβολα τόσο για το νέο σήμα, δηλαδή για τις
διαφορές που παράγει ο αλγόριθμος A-DPCM,
όσο και για τις παραμέτρους του γραμμικού προβλέπτη.

\subsection{Χρήση μετασχηματισμού Huffman}

\par Αφού υπολογίσαμε τα σύμβολα τα οποία αναπαριστούν το σήμα μας, θα τα
κωδικοποιήσουμε με τη χρήση του μετασχηματισμού Huffman. Πρώτα είναι, όμως,
απαραίτητο να προσδιορίσουμε τη συχνότητα εμφάνισης του κάθε συμβόλου. Μόλις
γίνει πρώτα υπολογίζουμε το κώδικα Huffman κάθε συμβόλου με τη συνάρτηση huffLUT
και στη συνέχεια υπολογίζουμε το μετασχηματισμό Huffman του παραθύρου με τη συνάρτηση
huff.

\subsection{Δημιουργία Bitstream}
\par Η διαδικασία που περιγράφτηκε παραπάνω είναι η κωδικοποίηση που γίνεται. Το
μόνο που μένει είναι να δημιουργήσουμε ένα bitstream που αποτελείται μόνο από 0
και 1. Κάθε παράθυρο έχει δικό του bitstream. Καθώς εκτελείται η όλη διαδικασία
που αναφέρθηκε παραπάνω έχουμε την μεταβλητή counter, η οποία μας μετράει πόσα
bits θα καταλάβει η κωδικοποίηση του παραθύρου. Αυτό είναι το πρώτο κομμάτι του bitstream
σε δυαδική μορφή σε 24 bits και είναι απαραίτητη ώστε να μπορέσουμε να ξεχωρίσουμε
κάθε bitstream για κάθε ένα από τα παράθυρα. Στη συνέχεια αποθηκεύουμε τον κώδικα Huffman
με 5 bits μπροστά από κάθε κωδικολέξη τα οποία προσδιορίζουν το μήκος της. Στη συνέχεια
αποθηκεύουμε τα 2 πρώτα επίπεδα κβάντισης, καθώς λόγω του ότι χρησιμοποιούμε ομοιόμορφο κβαντιστή
αρκούνε αυτά τα δύο για να ανακατασκευάσουμε τα υπόλοιπα ώστε να μπορέσουμε να ανακτήσουμε τον αποκβαντιστή κατά τη
διάρκεια της αποκωδικοποίησης. Ακόμα
αποθηκεύουμε τον ελάχιστο και τον μέγιστο συντελεστή πρόβλεψης οι οποίοι θα μας χρειαστούν
στην ανάστροφη διαδικασία A-DPCM. Τέλος αποθηκεύουμε και την κωδικοποίηση Huffman του
παραθύρου.

\subsection{Η συνάρτηση myEncoder}
\par Η κύρια συνάρτηση που ξεκινάει την κωδικοποιήση είναι η
\begin{lstlisting}[style=MyMatlab]
 function myEncoder(wavFilename, codedFilaneme)
\end{lstlisting}
όπου wavFilename το αρχείο που θα συμπιεστεί και codedFilename το όνομα του
συμπιεσμένου αρχείου. Αρχικά ο ήχος που διαβάζουμε από το αρχείο είναι σε δύο
κανάλια. Με τη χρήση της reshape τον μετατρέπουμε σε ένα κανάλι. Στη συνέχεια
αποθηκεύουμε το συνολικό μήκος του διανύσματος αυτού στην αρχή του κωδικοποιημένου
αρχείου γιατί θα το χρειαστούμε στην αποκωδικοποίηση, όπως θα φανεί παρακάτω. Στη συνέχεια
κάνουμε την διαδικασία που αναφέρθηκε παραπάνω καλώντας την συνάρτηση encoder. Στη συνέχεια
κάθε bitstream που μας έρχεται το βάζουμε στην σειρά και αποθηκεύουμε το αρχείο.


\section{Ολοκληρωμένος Αποκωδικοποιητής}
\par Παρακάτω παρουσιάζονται όλα τα βήματα που χρησιμοποιήσαμε για την σύνθεση ενός
αποκωδικοποιητή και στη συνέχεια τα θα αναλύσουμε το κάθε ένα από αυτά.
\begin{enumerate}
\item Καθορισμός του bistream κάθε παραθύρου.
\item Υπολογισμός όλων των απαραίτητων παραμέτρων από το bitstream.
\item Χρήση του αντίστροφου μετασχηματισμού Huffman.
\item Χρήση του αντίστροφου A-DPCM.
\item Σύνθεση του τελικού σήματος και υπερδειγματοληψία.
\end{enumerate}

\subsection{Καθορισμός του bitstream}
\par Κάθε φορά χρειάζεται να προσδιορίσουμε το μήκος του bitstream. Για
αυτό διαβάζουμε τα 24 πρώτα bits τα οποία περιέχουν το μήκος. Έτσι καταφέρνουμε
να υπολογίσουμε το bistream για κάθε παράθυρο. Στη συνέχεια καλούμε τη συνάρτηση
\begin{lstlisting}[style=MyMatlab]
 function [x, newstate] = decoder(b, state)
\end{lstlisting}
όπου b το bitstream του παραθύρου και x το αποκωδικοποιημένο σήμα.

\subsection{Υπολογισμός παραμέτρων}
\par Μόλις υπολογίσουμε το bitstream πρέπει μέσα από αυτό να εξάγουμε όλες τις
παραμέτρους που έχουμε κωδικοποιήσει. Πρώτα υπολογίζουμε τις κωδικολέξεις Huffman.
Τα 5 πρώτα bits περιέχουν τις λέξεις που ακολουθεί. Στη συνέχεια διαβάζουμε ταις δύο πρώτες στάθμες
κβαντισμού, με βάση αυτές υπολογίζουμε τις υπόλοιπες, ανακατασκεύαζοντας έτσι τον αποκβαντιστή,
καθώς και το ελάχιστο και το μέγιστο από τις παραμέτρους
του γραμμικού προβλέπτη. Τα υπόλοιπα bits που απομένουν είναι το κωδικοποιημένο
σήμα σε Huffman.

\subsection{Χρήση του αντίστροφου Huffman}
\par Έχοντας τις κωδικολέξεις και το κωδικοποιημένο σήμα υπολογίζουμε τα σύμβολα
του αρχικού μας σήματος με τη χρήση της συνάρτησης ihuff, όπως αναφέρεται και
παραπάνω.

\subsection{Χρήση του αντίστροφου A-DPCM}
\par Αφού έχουμε βρει τα σύμβολα από τα οποία αποτελείται το σήμα μας μπορούμε να
χρησιμοποιήσουμε το αντίστροφο A-DPCM. Πρώτα όμως πρέπει να φτιάξουμε έναν κβαντιστή.
Λόγω του ότι έχουμε το ελάχιστο και το μέγιστο x μπορούμε να φτιάξουμε έναν ομοιόμορφο
κβαντιστή. Στη συνέχεια με την χρήση της iadpcm κάνουμε την αποκωδικοποίηση του σήματος
και βρίσκουμε μία προσέγγιση του αρχικού.

\subsection{Σύνθεση του Τελικού Σήματος}
\par Κάθε παράθυρο από bits που βάζουμε στην συνάρτηση decoder μας επιστρέφει ένα
ένα από τα παράθυρα του αρχικού σήματος. Τα βάζουμε όλα αυτά στην σειρά και δημιουργούμε
το αρχικό μας σήμα. Στη συνέχεια, μέσω upsampling το επαναφέρουμε στην αρχική συχνότητα.

\subsection{Η συνάρτηση myDecoder}
\par Η κύρια συνάρτηση που ξεκινάει την αποκωδικοποίήση είναι η
\begin{lstlisting}[style=MyMatlab]
 function myDecoder(codedFilaneme, wavFilename)
\end{lstlisting}
όπου codedFilename το όνομα του συμπιεσμένου αρχείου και wavFilename το αρχείο που θα
αποθηκεύσουμε το αποσυμπιεσμένο αρχείο. Αρχικά το bitstream που διαβάζουμε στα 32 πρώτα
bits περιέχει το μήκος του αρχικού αρχείου το οποίο το αποθηκεύουμε. Στη συνέχεια κάνουμε
την παραπάνω διαδικασία και παίρνουμε το αποσυμπιεσμένο σήμα. Το σήμα αυτό το
φέρνουμε στην αρχική συχνότητα δειγματοληψίας, και το κάνουμε να έχει το ίδιο μήκος
με το αρχικό, επειδή κάποιες φορές λόγω στρογγυλοποιήσεων έχει διαφορετικό μήκος.
Με τη χρήση της reshape μετατρέπουμε το σήμα σε δύο κανάλια και το αποθηκεύουμε.

